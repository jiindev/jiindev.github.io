{"componentChunkName":"component---src-pages-blog-js","path":"/blog/","result":{"data":{"allMarkdownRemark":{"totalCount":2,"edges":[{"node":{"frontmatter":{"date":"2020. 5. 22","title":"JIIN,DEV 개발일지","thumbnail":null},"fields":{"slug":"/blog/about-jiindev/"},"excerpt":"웹개발자 취준에 있어 메인프로젝트라고 생각한 드림위치가 어느정도 마무리 되자 프로젝트와 이력들을 정리할 포트폴리오 사이트가 필요했습니다. 리액트를 배우기 시작하면서 리액트에 익숙해지면 그 다음으로 익히게 싶었던 것이\n1순위가 리액트 네이티브,…","timeToRead":7,"html":"<p>웹개발자 취준에 있어 메인프로젝트라고 생각한 드림위치가 어느정도 마무리 되자 프로젝트와 이력들을 정리할 포트폴리오 사이트가 필요했습니다. 리액트를 배우기 시작하면서 리액트에 익숙해지면 그 다음으로 익히게 싶었던 것이\n1순위가 리액트 네이티브, 2순위가 리액트 갯츠비였습니다. (3순위는 타입스크립트!) 퍼블리셔를 준비하던 시절에 브랜드 아이덴티티를 확실하게 드러내는 소개형 사이트를 여러가지 봤었는데, 그 과정에서 정적인 사이트에 큰 끌림을 느꼈던것 같습니다. 마침 리액트도 어느정도 익혔겠다, 포트폴리오 사이트는 리액트 갯츠비를 이용하여 개발하고자 마음먹게 됐답니다.\n<br><br>\n이제까지 공식사이트를 참고하여 프레임워크나 라이브러리를 익힐 때에 모두 한글화가 되어 있었는데 (리액트, 코드이그나이터...) 갯츠비 공식사이트는 한글 번역없이 영어로 되어있어 조금 머뭇거리게 됐습니다. 그렇지만 저같은\n초보자들도 이해하기 쉽도록 문서가 간결하게 작성되어 있어 걱정했던 것보다는 수월하게 튜토리얼을 따라갈 수 있었습니다. 일단은 폴더 구조가 이전에 next.js를 사용하여 진행했을 때와 동일했기 때문에 굳이 시간을 써가며\n이해할 필요가 없었습니다. css 처리의 경우 여러가지 방법이 있었는데, 공식 사이트에서 styled component의 사용을 권장하듯 적어놓았기에 직전에 사용하여 익숙해진 styled component를 그대로\n사용했습니다.\n<br><br>\n사이트의 구조는 다른 개발자 포트폴리오 사이트의 컨텐츠를 참고하여 결정했습니다. 거의 대부분의 개발자 포트폴리오 사이트가 자신에 대한 소개, 포트폴리오 작업물, 블로그로 구성되어 있었습니다. 이전에는 블로그의 필요성에 대해\n크게 느끼지 못했는데, 드림위치를 진행하면서 문제점이 발생하여 검색을 했을 때 자신의 문제와 해결방법을 서술해둔 블로그 포스팅에 도움을 굉장히 많이 받았습니다. 또, 문제가 발생했을 때 지난번에 겪고 해결한 문제임에도\n그 해결방법이 기억나지 않아 다시 똑같은 검색을 반복하는 경우도 많았고요. 뭔가 개발일지를 적어놓는 블로그가 필요하다는 생각을 마침 하고 있었기에 블로그에 적을 내용은 아직 많지 않지만, 앞으로 채워가야겠다는 뜻에서\n블로그까지 구현을 하기로 했습니다.</p>\n<h4>GRAPHQL</h4>\n<p>일단 갯츠비에서 블로그가 어떤 식으로 구현이 되는지에 대한 사전지식 하나도 없이 튜토리얼을 따라가게 됐습니다. 이번에 공식문서에 의지하며 갯츠비를 익히면서 느낀거지만 뭔가에 처음 익숙해질때 공식문서 튜토리얼만큼 좋은게 없는것 같습니다.. 이정도면 따라갈만 한데?를 연발하며 하나하나 따라가던 중 처음으로 난관에 부딪혔습니다. 바로 이전에 경험해본 적이 아예 없는 graphQL을 다루는 순간이 온것!\n일단 공식문서에 나와있는 걸 따라하면 여차저차 진행은 됐지만 graphQL 자체를 이해하기가 힘들었습니다. 앞으로 graphQL을 만날 기회는 많으니, 일단 블로그를 만들 수 있을 정도의 사전지식까지만 쌓고 진행하기로 했습니다.<br><br></p>\n<p><strong>graphQL의 개념을 이해하는 데 큰 도움을 준 영상 ⬇</strong></p>\n<iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/EkWI6Ru8lFQ\" frameborder=\"0\" allowfullscreen></iframe>\n<p>이전에 드림위치 작업은 REST API로 진행을 했는데, graphQL은 REST API의 대안으로 꼽히는 듯 합니다. REST API가 정의 내려져 있는 endpoint에 정해진 요청을 보내면 정해진 수순대로 데이터를 돌려주는 반면 graphQL은 훨씬 더 유연하게 요청을 보내 데이터를 가져올 수 있는 것. 각각의 장단점이 있기 때문에 상황에 따라서 복합적으로 사용하는 것을 권장하고 있습니다. </p>\n<br>\n<p><strong>REST API</strong></p>\n<ul>\n<li>장점 : 직관적이며 구현하기 단순하다. 범용성. </li>\n<li>단점 : 정의 내려진 동작만 처리가 가능하다. (유연하지 못함)</li>\n</ul>\n<p><strong>graphQL</strong></p>\n<ul>\n<li>장점 : 유연하다. 정해진 틀이 없음. 한번에 원하는 데이터 처리가 가능하여 요청의 횟수를 줄일 수 있다. </li>\n<li>단점 : text만으로 전달하기 힘든 데이터는 처리가 어렵다. 고정된 요청과 응답만이 필요할 경우엔 효율적이지 못하다.</li>\n</ul>\n<br>\nDB를 연결하지 않고 어떻게 블로그를 만들 수 있다는 건지가 참 궁금했는데, graphQL로 사이트의 구조를 분석하여 특정 폴더에 있는 마크다운 파일들의 데이터를 가져오는 것이 가능했습니다. gatsby-node.js 파일을 만들어 빌드 시 마크다운 파일들을 각각의 페이지로 만들어 링크로 연결이 가능하도록 설정하여, 단순히 pages 안에 마크다운 파일을 넣어두는것만으로 블로그란에 포스팅을 추가할 수 있었습니다.\n<h4>TRANSITION</h4>\n만들기 전 걱정했던 블로그 연결 등은 튜토리얼을 따라가며 무난하게 잘 끝냈으나 페이지 전환에서 긴 시간을 썼습니다. 다른 페이지로 이동할 때에 일반 사이트처럼 아무런 전환효과 없이 이동하게 되는데, 이왕 SPA로\n사이트를 만들었으니 페이지 간 전환효과를 넣고 싶다는 생각이 들었습니다. 마침 갯츠비의 경우 키워드만 잘 조합해서 검색하면 금방 내가 원하는 플러그인 혹은 라이브러리 관련 공식 문서가 나왔기 때문에 크게 문제없이 구현할\n수 있으리라고 생각했습니다.\n<p>서치를 통해 갯츠비로 페이지 전환 효과를 낼 수 있는 방법 두가지를 찾았습니다.\n<br /><br />\n첫번째는 <a href=\"https://transitionlink.tylerbarnes.ca/docs/\">gatsby-plugin-transition-link</a>를 이용한 전환효과\n주기. 검색을 하자마자 갯츠비 공식문서에 <a href=\"https://www.gatsbyjs.org/docs/adding-page-transitions-with-plugin-transition-link/\">관련 글</a>이 나왔습니다. 일단 <a href=\"https://gatsby-plugin-transition-link.netlify.app/\">데모\n사이트</a>에서 보여지는 애니메이션 효과가 굉장히 화려했던지라 바로 눈길을 잡았습니다. AniLink로 이와 같은 효과를 아주 간단한 방법으로 줄 수 있는데, 무궁무진한 애니메이션 효과 중 하나를 골라\n적용하는걸 기대하고 들어왔으나 적용할 수 있는 애니메이션이 fade, paintDrip, swipe, cover 네가지밖에 없었습니다. 간단한 페이드인아웃 전환효과를 구현하고 싶었는데, AniLink로 낼 수 있는\n페이드인아웃 효과는 시간차없이 동시에 전환되어서 썩 보기 좋지가 않았습니다. 그 외의 효과들은 간단한 코드로 화려한 효과를 낼 수 있다는 장점이 있었지만 심플한 제 사이트와는 어울리지가 않았습니다. AniLink의 fade\n효과를 동시에 주지 않고 시간차로 줄 수 있는 방법이 없나 찾아보았지만 찾은 답변은 해당 플러그인은 유연성이 떨어지기 때문에 추천하지 않는다는 글 뿐이었습니다. TransitionLink를 사용하여 커스텀해볼까 하는\n생각도 들었지만 검색하는 과정에서 react-transition-group을 알게 되었습니다.\n<br /><br />\n두번째로 시도하게 된 <a href=\"https://reactcommunity.org/react-transition-group/\">react-transition-group</a>,리액트에서 가장 잘 알려진 전환 애니메이션 라이브러리라고 하네요. 이런게 있는줄 알았더라면 드림위치에서도 써볼걸 하는 후회와 함께... 서치를 해보니 갯츠비에서 적용하는 방법을 상세하게 적어놓은 <a href=\"https://www.digitalocean.com/community/tutorials/how-to-animate-page-transitions-on-a-static-gatsbyjs-site\">튜토리얼 포스트</a>가 있어서 이를 참고하여 진행했습니다.</p>\n<p>적어놓은 전환 효과도 내가 원했던 시간차 페이드인&#x26;아웃 효과였기 때문에 코드 이해를 하는것 외엔 거의 동일하게 진행했습니다. 스크롤을 내렸을 때에 다른 페이지 링크를 클릭하면 스크롤 최상단으로 이동한 후 페이지가\n바뀌어 거슬렸는데 이에 대한 해결방법도 자세히 적혀 있었습니다. </p>\n<pre><code>const transitionDelay = 500\nexports.shouldUpdateScroll = ({\n    routerProps: { location },\n    getSavedScrollPosition,\n}) => {\n    if (location.action === 'PUSH') {\n        window.setTimeout(() => window.scrollTo(0, 0), transitionDelay)\n    } else {\n        const savedPosition = getSavedScrollPosition(location)\n        window.setTimeout(\n            () => window.scrollTo(...(savedPosition || [0, 0])),\n            transitionDelay\n        )\n    }\n    return false\n}\n</code></pre>\n<p>현재 스크롤값을 기억한 뒤 페이지가 변환되는 타이밍에 스크롤이 0,0으로 가지 않고 기억한 스크롤값으로 이동하게 한 뒤, 페이지가 전환된 후에는 0,0으로\n스크롤을 이동시키는 코드를 gatsby-browser.js로 작성하니 페이지가 어색하지 않게 전환될 수 있었습니다.</p>\n<p>이 과정에서 생긴 문제점! transition 파일에 layout에서 생성된 location 객체를 넘겨주어 transition.js에서 location.pathname을 key값으로 사용하게 되는데 블로그 포스팅\nmd파일로 빌드시킨 링크의 경우 location 객체가 계속 undefined로 뜨는 문제가 있었습니다.</p>\n<p><strong>TypeError: Cannot read property 'pathname' of undefined</strong></p>\n<p>처음에는 이런 방식으로 빌드시킨 경우엔 갯츠비가 location 객체를 얻어오지 못하나? 하는 생각에 location 객체가 없을 경우 빈 객체를 넣어주는 식으로 수정하고, location.pathname을\nkey값으로 갖는 코드도 임시로 지우고 진행을 했습니다. 계속 key를 지정하지 않아 에러가 뜨는 것이 신경쓰여 location을 콘솔에 찍어봤는데, location이 제대로 한번 뜨고 바로 이어서 undefined가\n따라왔다. 왜 location이 한번 로드된 이후에 undefined로 바뀌는지에 대해선 자세한 원인을 찾지 못했습니다. 그렇지만 제 예상과는 달리 처음에 렌더되었을 때 location이 제대로 따라오는 것은 맞았기에\nlocation.pathname을 location &#x26;&#x26; location.pathname으로 바꿔주었더니 이후 블로그 포스팅 링크에 들어갔을 때도 트랜지션이 제대로 동작했습니다.</p>\n<pre><code>&#x3C;TransitionGroup>\n    &#x3C;ReactTransition \n    key={location &#x26;&#x26; location.pathname} \n    timeout={{ enter: timeout, exit: timeout }}\n    >\n        {status => (\n        &#x3C;div style={{\n                ...getTransitionStyles[status],\n              }}>\n            {children}\n        &#x3C;/div>\n        )}\n    &#x3C;/ReactTransition>\n&#x3C;/TransitionGroup>\n</code></pre>\n<h4>YAML &#x26; 코드 중복 잡기!</h4>\n<p>works 페이지에서 같은 코드가 여러번 반복되는 문제점이 있었습니다. 데이터를 수정하기 위해서는 각 li코드 내부의 복잡한 코드들을 읽어가며 맞는 위치에 원하는 데이터를 적어넣어야 했기 때문에 직관적이지 못했습니다.</p>\n<p>보다 효율적인 코드작성을 위해, works의 데이터들을 따로 전달하고 map 함수를 이용하여 이것을 정해진 형태로 화면에 뿌려지는 방식으로 코드를 전환하기로 했습니다. 여태껏 데이터를 전달해줄 때엔 json 형식을 사용했기 때문에 이번에도 익숙한 json을 사용하고자 하였으나, 갯츠비의 테마배포 튜토리얼을 보던 중 같은 상황에서 yaml 형식으로 데이터를 전달해주는 것을 보았습니다. </p>\n<br/>\n<p><strong>[json 형식]</strong></p>\n<pre><code>{\n    title: 'DREAMWITCH',\n    date: '2020. 04 - 2020. 05',\n    description: '투두리스트 SNS 웹서비스를 공동기획 및 풀스택 개발했습니다. \n    그날 하루동안의 해야 할 일을 기록하고,\n    12시가 가기 전에 미션을 성공하면 보상을 줌으로써 사용자에게 동기부여를 줍니다. \n    모은 화폐로는 아바타를 커스터마이징 할 수 있으며, \n    다른 사용자의 페이지에 방문하여 덧글을 남김으로써 소통할 수 있습니다. \n    AWS에서 EC2서비스를 이용하여 배포하였습니다.',\n    skills: ['REACT (REACT HOOKS)','REDUX &#x26; REDUX-SAGA', \n            'NEXT.js', 'Express.js', 'STYLED COMPONENT',\n            '서버사이드 렌더링', 'AWS 배포'],\n    siteUrl: 'http://dreamwitch.kr/',\n    githubUrl: 'https://github.com/jiindev/DREAMWITCH',\n    imgLink: '/dreamwitch.jpg',\n    blogUrl: '/blog/about-dreamwitch/'\n}\n</code></pre>\n<p><strong>[yaml 형식]</strong></p>\n<pre><code>- title: DREAMWITCH\n  date: 2020. 04 - 2020. 05\n  description: |\n    투두리스트 SNS 웹서비스를 공동기획 및 풀스택 개발했습니다. \n    그날 하루동안의 해야 할 일을 기록하고,\n    12시가 가기 전에 미션을 성공하면 보상을 줌으로써 사용자에게 동기부여를 줍니다. \n    모은 화폐로는 아바타를 커스터마이징 할 수 있으며, \n    다른 사용자의 페이지에 방문하여 덧글을 남김으로써 소통할 수 있습니다. \n    AWS에서 EC2서비스를 이용하여 배포하였습니다.\n  skills: \n    - REACT (REACT HOOKS)\n    - REDUX &#x26; REDUX-SAGA\n    - NEXT.js\n    - Express.js\n    - STYLED COMPONENT\n    - 서버사이드 렌더링\n    - AWS 배포\n  siteUrl: http://dreamwitch.kr/\n  githubUrl: https://github.com/jiindev/DREAMWITCH\n  imgLink: /dreamwitch.jpg\n  blogUrl: /blog/about-dreamwitch/\n</code></pre>\n<p>갯츠비 문서에서 사용을 권장하고 있기도 하고, json보다 yaml 형식의 데이터가 직관적이고 보다 간편하다는 인상을 받아 yaml으로 데이터를 전달해주기로 했습니다.</p>\n<br/>\n<p><strong>[복잡했던 코드를 map 함수를 이용해서 반복시켜 간결화]</strong></p>\n<pre><code>{worksData.map((v, i)=>{\nreturn (\n&#x3C;Work key={i}>\n    &#x3C;div className=\"center\">\n        &#x3C;Image link={v.imgLink}>&#x3C;/Image>\n        &#x3C;div className=\"description\">\n            &#x3C;h4>{v.title}&#x3C;/h4>\n            &#x3C;Date>{v.date}&#x3C;/Date>\n            &#x3C;p>{v.description}&#x3C;/p>\n            &#x3C;ul>\n                {v.skills.map((skill, skillKey)=>{\n                return &#x3C;li key={skillKey}>{skill}&#x3C;/li>\n                })}\n            &#x3C;/ul>\n            &#x3C;div>\n                {v.siteUrl &#x26;&#x26; &#x3C;a href={v.siteUrl} target=\"blank\">&#x3C;Button>사이트 바로가기&#x3C;/Button>&#x3C;/a>}\n                {v.githubUrl &#x26;&#x26; &#x3C;a href={v.githubUrl} target=\"blank\">&#x3C;Button>&#x3C;i className=\"fab fa-github\" /> GITHUB\n                        바로가기&#x3C;/Button>&#x3C;/a>}\n                {v.blogUrl &#x26;&#x26; &#x3C;GatsbyLink to={v.blogUrl}>&#x3C;Button>개발일지 보기&#x3C;/Button>&#x3C;/GatsbyLink>}\n            &#x3C;/div>\n        &#x3C;/div>\n    &#x3C;/div>\n&#x3C;/Work>\n)\n})}\n</code></pre>\n<p>데이터를 복잡한 코드의 내부에서 편집하던 이전과는 달리 yaml 파일 데이터 수정 시 바로 사이트에 반영이 되어 보다 간단하게 내용을 수정할 수 있도록 개선했습니다. </p>\n<h4>THEME</h4>\n<p>데이터를 화면에 뿌려주는 방식을 위의 방식대로 바꾸고 나니 커스텀에 용이하겠다는 생각이 들었습니다. about 페이지를 살펴보니 마찬가지로 반복되는 데이터가 보였고 (경험을 서술한 리스트 형식의 데이터가 반복) 동일한 방식대로 코드를 단축시킬 예정입니다. 기존의 갯츠비 테마를 사용하지 않고 처음부터 끝까지 스스로 구현해낸 것은 갯츠비를 공부하고 싶다는 학구열도 있었지만, 테마중에 제가 원하는 스타일이 없어서이기도 했습니다. 이런 깔끔한 스타일의 포트폴리오 테마를 원하는 이들이 있을 수도 있다는 생각이 들어, 추후 갯츠비 테마로 배포하고자 합니다. <a href=\"https://www.gatsbyjs.org/docs/themes/building-themes/\">(튜토리얼 링크)</a></p>"}},{"node":{"frontmatter":{"date":"2020. 5. 21","title":"드림위치 개발일지","thumbnail":"/blog/about-dreamwitch0.jpg"},"fields":{"slug":"/blog/about-dreamwitch/"},"excerpt":"제로초님의 트위터 클론 사이트 노드버드 제작하기 강의를 끝까지 수강하여 next와 express…","timeToRead":7,"html":"<p>제로초님의 트위터 클론 사이트 노드버드 제작하기 강의를 끝까지 수강하여 next와 express를 이용해 하나의 사이트를 만드는 일련의 과정을 따라갔으나, 스스로 그런 사이트를 만들 수 있을지에 대해 확신이 서지 않았습니다. 확실하게 내것으로 만들기 위해서 뭔가의 토이프로젝트를 진행해야 한다는 생각을 하던 중, 함께 종종 웹작업을 해온 친구 지수가 제게 달성표를 디자인하여 줬습니다.</p>\n<p><img src=\"/blog/about-dreamwitch2.png\" alt=\"지수의 달성표\"></p>\n<p>당시 저는 트렐로의 체크리스트 기능을 이용하여 매일 그날 할 일을 미션처럼 적고 수행하는 일을 반복하고 있었는데, 트렐로 자체가 그런 체크리스트 기능을 메인으로 내세우는 사이트가 아니었기 때문에 불편함을 느끼고 있었습니다. 그럼에도 불구하고 트렐로를 계속 사용하던 이유는 내가 원하는 방식의 투두리스트 앱을 찾지 못해서였습니다. 내가 이룬 일들이 기록되는 투두리스트 어플을 원했지만 적절한 것이 없었습니다.</p>\n<p>지수가 만들어온 달성표를 보고 토이프로젝트를 색다른 방식의 투두리스트 웹으로 진행하면 재밌겠다는 생각이 들었고 기획은 함께, 디자인은 지수가, 코드는 제가 짜는 방식으로 함께 시작하게 되었습니다.</p>\n<h4>CONCEPT</h4>\n<p>지수와 저의 당시 공통 관심사는 게이미피케이션이었습니다. 자연스럽게 게임 방식으로 미션을 성공하면 보상을 주어 사용자가 투두리스트를 달성하도록 동기부여를 하는 방향으로 진행하게 됐습니다.</p>\n<p>이전에 지수와 카툰타투 할로윈게임 사이트를 함께 진행하면서 지수의 일러스트가 웹에 얹어졌을 때의 느낌을 두사람 모두 매우 만족스러워 했기 때문에 이번에도 그런식으로 디자인을 진행하기로 했습니다.</p>\n<p><img src=\"/blog/about-dreamwitch0.png\" alt=\"드림위치 로고\"></p>\n<p>사이트의 컨셉은 빠르게 결정됐습니다. 지수가 처음 디자인해온 달성표를 보고 추억의 애니메이션 꼬마마법사 레미같다는 인상을 받으면서 대화를 나누다보니 ‘견습 마녀가 승급을 위해 인간을 도와준다, 인간이 꿈을 위해 노력했을 때 나오는 꿈의 구슬로 성장한다’는 동화스러운 도입부가 자연스럽게 나왔습니다.</p>\n<p>학부시절부터 ‘언젠간 꼭 웹으로 구현해보고싶다!’라고 생각하던 것 중 하나가 커스터마이징이었습니다. 투두리스트 미션을 달성할 경우엔 게임머니를 주고, 모은 게임머니로는 자신의 아바타를 커스터마이징하는 기능을 메인으로 두기로 했습니다. 사용자에게 성취감을 주기 위해 메인에 내가 꾸민 아바타를 보여주기로 했고, 사이트에서 어떠한 동작을 수행하면 아바타가 이에 대한 반응을 구현하고자 했습니다.</p>\n<p>nodebird 사이트 제작을 따라할 때는 강의에서 보여주는 그대로 따라하면 되니 자잘한 오타로 에러가 뜨는것 외에느 큰 어려움을 느끼지 못했는데, 직접 사이트를 개발해보니 이런 저런 변수가 발생하여 애를 먹었습니다. 최대한 혼자 풀어보고자 하고, 도무지 진행이 안된다 싶을 때에 강의 사이트에 질문글을 올려 조언을 얻으면서 하나하나 완성해나갔습니다.</p>\n<p><img src=\"/blog/about-dreamwitch3.png\" alt=\"결국 sns기능까지 갖추게 된 드림위치\"></p>\n<p>드림위치는 처음엔 아주 간단하게 진행하고자 하였으나 진행중에 아이디어가 생겨 이런저런 기능을 추가로 넣은 사이트입니다. 처음엔 sns 기능 없이 그저 개인의 데이터만 볼 수 있는 식이었는데, 그렇게 진행하자니 express를 사용하는 의미가 크게 없는것 같아서 중간에 sns 형식으로 바꾸자는 아이디어가 나왔습니다. 개인 사이트가 아닌 소셜 네트워킹 사이트로 바꾸면서 다른 이의 페이지를 확인하고, 덧글을 달 수 있는 기능을 추가했습니다.</p>\n<h4>지난 투두 보여주기, lastStart</h4>\n<p>로그인하여 투두리스트 탭에 오면 오늘 날짜에 사용자가 등록한 todo 데이터들을 보여주며 밤 12시가 지나서 날짜가 바뀌게 되면 투두리스트가 리셋되어 텅 비게 됩니다. 실패/성공에 대한 피드백 없이 바로 투두리스트 화면이 비어버리는 흐름이 어색하게 느껴졌고, 결국 지난 날짜에 대한 성공/실패 여부를 날짜가 바뀌었을 때 화면에 보여주기로 하였습니다. </p>\n<p>오늘 날짜에 해당하는 todo 데이터가 없을 경우 지난 투두를 불러오는 동작을 수행합니다. 사용자가 입력한 todo 데이터들 중 가장 최근의 todo 데이터를 불러오고, 해당 데이터의 날짜와 일치하는 사용자의 todo 데이터들을 불러와 화면에 뿌려줬습니다. </p>\n<p>오늘 등록한 todo들을 모두 마치고 완료를 눌렀을 때 해당 날짜의 history가 생성되고 그 history에 todo 데이터들을 연결시켰기 때문에(1:N 관계), 만약 todo 데이터가 historyId를 가지고 있다면 그날의 미션이 성공했다는 것을 의미합니다. 따라서 지난 todo 데이터들을 불러왔을 때에 historyId를 갖고 있다면 성공, 아닐 경우 실패로 결과를 보여주도록 했습니다.</p>\n<p>이 때 문제가 생겼습니다. 지난 결과를 확인한 후 오늘 날짜로 todo를 입력하지 않는다면 다시 접속했을 때 이미 결과를 확인하고 시작을 눌렀음에도 또 다시 지난 결과를 보여주게 됩니다. 결과를 확인하고 시작을 눌렀다면 다시 결과를 보여주지 않도록 하기 위해서 어떻게 처리해야 할지 고민을 하다가 User 모델에 lastStart 컬럼을 새로 만들어주었습니다. 초기값은 0으로, 사용자가 지난 결과를 확인하고 시작하기를 눌렀을 때에 lastStart를 해당 날짜로 갱신해주어 지난 todo를 불러오는 동작을 수행할 때에 조건을 lastStart의 날짜 이후에 생성된 todo들을 불러오는 것으로 추가해주었습니다.</p>\n<h4>TIME</h4>\n<p>특히나 코드수정이 가장 많이 이루어진 부분은 날짜처리 부분이었습니다. </p>\n<p>기획 상 투두리스트가 12시를 기점으로 성공과 실패 여부를 판단했기 때문에 데이터를 불러올 때 시간을 기준으로 조건을 주어야 하는 경우가 빈번했습니다. sequelize에선 데이터를 생성할 때에 createAt, updatedAt 컬럼을 자동으로 생성하여 해당 시각을 기록해주어 이것을 사용하기로 했습니다. 그러자 9시간의 시간차가 생겨 원하는 시기의 정보를 불러오지 못하는 문제가 생겼습니다. 처음엔 이 문제를 해결하기 위해서 date라는 컬럼을 따로 만들어주고 todo 데이터 생성 시 현재 시각의 날짜값을 date에 넣어주고 이 date를 기준으로 데이터를 가져왔습니다. 기능은 제대로 동작했으나 date 컬럼은 createAt 컬럼과 의미하는 바가 중복되었고, 코드가 지저분해지는 문제가 생겨 다른 개선방법을 찾게 되었습니다. sequelize의 timezone 설정을 한국의 timezone과 일치시켜주었고 그렇게 적용하니 date 컬럼을 따로 둘 필요 없이 기존에 있던 createAt를 기준으로 데이터 조회 처리를 할 수 있었습니다. <a href=\"https://lemontia.tistory.com/873\">(참고한 포스팅)</a></p>\n<p>이후에 createAt에 주는 조건이 점차 복잡해지면서 코드가 어지럽게 되어 다시 정리를 해야할 필요성을 느끼게 되었습니다. Date객체의 경우 백엔드에서 불러올 때와 프론트에서 불러올 때에 그 형식이 달라서 통일이 힘들었기 때문에 먼저 String 형태로 바꾼 후 뒤의 필요없는 부분을 잘라내는 형식으로 데이터를 처리했는데, 이 과정에서 코드가 쓸데없이 늘어난다는 인상을 받게 되었습니다. 찾아보니 moment.js를 이용하여 이러한 Date 객체를 원하는 방식으로 편하게 커스텀할 수 있다는 것을 알게 되었고 날짜를 처리하는 전체 코드를 moment.js를 이용하여 깔끔하게 정리했습니다. </p>\n<p>이렇게 시간처리 문제는 제대로 해결이 되었다고 생각했으나, 배포를 하니 또 다시 문제가 생겼습니다. 12시가 넘어서 들어갔음에도 투두리스트가 리셋되지 않고 그대로 전날의 투두리스트가 남아있었던 것입니다. 배포 첫날 새벽에 이를 깨닫고 이런 저런 수정을 해보았으나 근본적인 문제 파악이 힘들어 고민하던 중 아침 9시가 지나 사이트에 재접속해보니 투두리스트가 리셋되고 결과화면이 나타났습니다. 알고보니 sequelize의 timezone을 바꾸었지만, EC2의 timezone은 미국시간으로 설정되어 있어 9시간 느렸던 것이었습니다. EC2의 timezone 설정을 한국기준으로 바꾸었으나 계속하여 시간차가 발생했고 결국 moment.js의 timezone 설정을 이용하여 불러온 시간의 timezone을 한국 기준으로 변경처리하는 방법으로 시간문제를 해결할 수 있었습니다. 이전에는 백엔드 작업까지 하더라도 시간을 기준으로 조건을 주는 데이터처리를 겪어본 적이 없어 시간을 다루는 방법에 대해 무지했는데, 이번 기회로 시간처리로 생기는 여러가지 문제들을 파악하고 해결하는 방법을 익힐 수 있었습니다.</p>\n<h4>RE-RENDERING</h4>\n<p>그 다음으로 고전했던 것은 쓸데없는 리렌더링을 막는 최적화 작업이었습니다. 리렌더링을 막기 위한 방법으로 다들 React memo를 권장했기 때문에 memo를 이용한 최적화를 진행하였으나 데이터의 값에 따라 처리되는 동적인 부분은 관련없는 데이터를 처리하는 동작에도 계속 리렌더링이 되는 문제점이 있었습니다. 이를 막기 위해 데이터 처리가 일어나는 부분을 따로 컴포넌트로 분리하였습니다. 이것으로 몇몇 불필요한 리렌더링을 막았지만 그럼에도 불구하고 계속하여 리렌더링이 발생하는 부분이 있었습니다. </p>\n<p>수행하는 동작에서 다루는 데이터가 리렌더링 되는 부분과 전혀 연관이 없었기 때문에 원인을 파악하기가 힘들었고, 동작 수행 시 어떠한 데이터가 영향을 받는 것인지 알아보기 위해서 불필요한 리렌더링이 발생하는 컴포넌트에서 useEffect를 이용하여 테스트를 해보았습니다. useEffect의 배열값에 데이터 하나하나를 대입시켜 가며 동작을 수행하여 console.log로 변화하는 데이터가 무엇인지를 파악했습니다. 그렇게 테스트를 해보니 특정 데이터 값에 변동이 생길 경우 같은 리듀서에 존재하는 데이터까지 영향을 받는다는 것을 확인했고, useSelector로 데이터를 가져올 때에 구조 분해 문법으로 데려온 데이터를 하나씩 분리하여 선언하는 방식으로 수정하여 불필요한 리렌더링이 발생하지 않도록 정리할 수 있었습니다.</p>\n<h4>REST API 설계</h4>\n<p>프로젝트가 끝나 배포를 한 이후, REST API의 개념에 대해 다시 확인하게 됐고 제가 REST API의 의의에 맞지 않는 설계를 했단 것을 깨달았습니다.</p>\n<p>예를 들어 새로운 히스토리를 추가하는 동작을 수행하게 되면 백엔드의 /history post API에서 히스토리를 추가하는 동작뿐만 아니라 히스토리를 작성한 보상으로 사용자의 star(게임화폐)를 10 증가시키고 exp(경험치)를 1 증가시키는 동작까지 수행하는 식으로, 해당 URI에서 처리한다고 route로 명시한 데이터 처리동작외에 다른 자원까지 수행하는 방식으로 백엔드를 설계한것입니다. 이렇게 되니 특정 데이터의 처리를 API를 추가하여 분리하지 않고 다른 데이터를 처리하는 김에 해당 API에서 추가로 처리하게 되어 코드가 중복되고 REST API의 장점 중 하나인 직관성을 깨뜨린다는 생각이 들었습니다. 사이트를 다 완성하여 배포하고 기능적으로 문제가 없었지만 이러한 점이 신경 쓰여 결국 시간을 내어 이런 식으로 잘못 설계되었다고 생각되는 API들을 URI에 명시된 행동만을 하도록 분리하여 정리했습니다. 예를 들어 위에 명시했던 /history POST API에선 히스토리 데이터를 작성하는 행동만 하고, 히스토리를 작성하는 처리가 완료되면 /user/star PATCH API로 사용자가 가진 star를 수정하고, 또 /user/exp PATCH API에서 사용자의 exp를 증가시키는 식으로 분리하였습니다. 기능적으로 차이는 없었지만 이렇게 코드를 수정하니 해당 API가 어떠한 기능을 수행하는지가 수정전보다 훨씬 직관적으로 느껴졌습니다. 이번 프로젝트를 통해 REST API의 개념을 처음 접하고 적용한지라 제가 설계한 REST API의 구조가 완벽하다고 자신할 수는 없으나, 어떠한 방향으로 설계를 해야 RESTful한 API가 되는지에 대해 고민하는 좋은 경험이 되었습니다.</p>\n<h4>아쉬운 점</h4>\n<p>화면에 어떻게 보이는지가 신경쓰여 크롬 개발자도구로 각 디바이스별 화면을 체크해가며 style을 진행했는데, 그 때엔 아무런 문제가 보이지 않아 안심하고 사이트를 배포하여 주변인들에게 링크를 나눠줬습니다. 안드로이드는 큰 문제가 보이지 않았는데 유독 아이폰에서 문제가 생겼습니다. </p>\n<p>첫번째 문제는 아이폰이 키보드 입력 상태가 되면 활성화된 input폼을 중심으로 화면을 zoom 시키는데 친구들이 입력하기가 너무 불편하다고 하소연한것입니다. 찾아보니 아이폰의 해당 기능은 viewport 태그에 “ maximum-scale=1, user-scalable=no”를 추가하니까 더이상 화면을 자동확대하지 않게 되어 해결됐습니다. </p>\n<p>문제는 두번째였습니다. 핸드폰사이즈로 보았을 때에 화면의 높이만큼 사이트의 높이를 설정했는데, 아이폰에선 이 화면 높이가 주소창까지 포함하여 처리되는 것인지 계속 화면에 세로스크롤이 생겨 스크롤을 내린다면 아바타의 얼굴이 제대로 보이지 않는 문제점이 있습니다. 현재 적절한 해법을 찾지 못해, 코로나 시기가 끝나고 친구의 아이폰으로 테스트할 수 있는 날이 오면 실시간으로 테스트를 해가며 문제를 해결할 예정입니다.\n<br/><br/></p>\n<p>드림위치는 디자인이 모바일 사이즈 화면을 기준으로 나왔기 때문에 PC버전 사이즈의 경우 임의로 사이즈를 제한하는 프레임을 넣어 그 안에서 화면이 처리되도록 했습니다. 크게 불편하진 않지만 아무래도 모니터에서 봤을 때 조금 답답한 인상이 드는것도 같아서 기회가 생긴다면 PC버전 레이아웃을 한번 변경해보고 싶습니다. 게임머니를 얻는 방법이 투두 미션을 완료하는 것 하나밖에 없어 조금 아쉽고요. 구직활동 이후 필요한 부분을 보충하여 정식배포하고자 하는데 그 때엔 친구의 진행중인 투두를 응원해주면 그 투두미션이 성공했을 때에 친구와 사용자 모두에게 조금의 보상이 돌아가는 식의 기능을 추가하고 싶습니다.</p>\n<h4>좋았던 점</h4>\n<p>일단 제가 평소에 필요하다고 느꼈던 기능의 사이트를 직접 만들게 되어 좋았습니다. 아마존을 통해 배포를 완료한 이후에 몇몇 친구들에게 링크를 나누어주었는데, 고맙게도 그중 몇명의 친구들은 아직까지 드림위치를 사용하고 있습니다. 그것이 너무 고맙고, 뿌듯하게 느껴졌습니다. 그리고 리액트, next.js, express.js 등... 강의를 따라가면서 사용해보긴 했지만 내것이 아닌것 같았던 기술들을 이번 기회에 제대로 익힐 수 있었습니다. 특히나 시퀄라이즈의 경우 복잡한 조건값을 주는 방법을 익힐 수 있었습니다. </p>\n<p>매번 닷홈이나 카페24에 ftp로 업로드하는 방식으로만 사이트를 배포하고, react로 만든 풀스택 사이트를 아마존을 통해 배포해보는 것은 처음이었는데 한번 해보니 생각 외로 복잡하지 않았습니다. 도메인을 구매하여 내 사이트에 연결해본 경험도 처음이었습니다! </p>\n<p>자바스크립트 프레임워크의 튜토리얼에 빠짐 없이 있는것이 투두리스트여서 구현하기 쉬울거라고 생각되었는데 막상 해보니 시간을 기준으로 조건을 주어 데이터를 처리하는 작업이 많아서 의외로 힘들었습니다. </p>\n<p>드림위치를 구현하는 과정에서 처음에는 막연하게만 느껴졌던 것을 어떻게든 방법을 찾아내 구현해내는 경험을 많이 했습니다. 이 과정에서 문제를 어떻게 해결해야 하는지 제대로 부딪혀본 것 같아서 좋았고… 리액트의 개념에 대해 제대로 이해하기가 어려워 계속 강의만 반복하여 들었는데, 그런 식으로 개념만을 익히는 것보다 실제로 프로젝트를 직접 만들면서 경험하는 것이 훨씬 더 와닿는 공부법이구나 깨닫게 됐습니다.</p>\n<br/>\n<a href=\"http://dreamwitch.kr/\" target=\"blank\">드림위치 바로가기</a>"}}]}},"pageContext":{}}}